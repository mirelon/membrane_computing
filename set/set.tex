\documentclass[llncs,submission,copyright,creativecommons]{../lib/lncs/llncs}
\providecommand{\event}{Cie-CS 2015} % Name of the event you are submitting to

\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}

\usepackage{fontenc}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{makeidx}

% Repeat the same theorem in the appendix
\usepackage{thmtools, thm-restate}
\let\theorem\relax
\declaretheorem{theorem}

\pagestyle{headings}
\bibliographystyle{../lib/lncs/splncs}

\def\eps{\varepsilon}
\def\red{\color{red}}
\def\green{\color{green}}
\def\goodgap{\hspace{\subfigcapskip}}
\renewcommand\refname{References}

% Itemize bulet types
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\cdot$}

% Narrow texts in boxes
\providecommand{\narrow}[1]{\scalebox{.8}[1.0]{#1}}

\begin{document}
\title{Sequential P Systems with Active Membranes without counting\thanks{Work supported by the grant VEGA 1/1333/12.}}
\author{Michal Kováč}
\institute{Faculty of Mathematics, Physics and Informatics, Comenius University}
\date{\today}
\maketitle

\begin{abstract}
We study variants of P systems that are working in the sequential mode. Basically, they are not computationally universal, but there are possible extensions that can increase the computation power. Extensions that implement a notion of zero-checking, are often computationally universal.
P systems with an ability to create new membranes are a rare exception as they are known to be computationally universal even in the sequential mode without using a dedicated zero-check operation. Using sets instead of multiset was inspired by Reaction systems and we show how to use this relaxation in the context of active membranes.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

% Bio motivation

Membrane systems (P systems) \cite{Paun10OxfordHandbookMembraneComputing} were introduced by P\u{a}un (see \cite{Paun2000108}) as distributed parallel computing devices inspired by the structure and functionality of cells. Starting from the observation that there is an obvious parallelism in the cell biochemistry and relying on the assumption that ``if we wait enough, then all reactions which may take place will take place'', a feature of the P systems is given by the maximal parallel way of using the rules. For various reasons ranging from looking for more realistic models to just more mathematical challenge, the maximal parallelism was questioned, either simply criticized, or replaced with presumably less restrictive assumptions.
In some cases, a sequential model may be a more reasonable assumption. In sequential P systems, only one rewriting rule is used in each step of computation. Without priorities, they are equivalent to Petri nets \cite{Ibarra05Active}, hence not computationally universal. However priorities, inhibitors and other modifications can increase the computation power. It seems that there is a link between universality and ability to zero-check \cite{Alhazov12Properties}.

\section{Preliminaries}
\label{sec:preliminaries}

Here we recall several notions from the classical theory of formal languages.

An {\bf alphabet} is a finite nonempty set of symbols. Usually it is denoted by $\Sigma$. A {\bf string} over an alphabet is a finite sequence of symbols from the alphabet. We denote by $\Sigma^*$ the set of all strings over an alphabet $\Sigma$. By $\Sigma^+$ = $\Sigma^* - \{\eps\}$ we denote the set of all nonempty strings over $\Sigma$. A {\bf language} over the alphabet $\Sigma$ is any subset of $\Sigma^*$.

The number of occurrences of a given symbol $a\in \Sigma$ in the string $w\in \Sigma^*$ is denoted by $|w|_a$. $\Psi_\Sigma(w)=(|w|_{a_1},|w|_{a_2},\dots,|w|_{a_n})$ is called a Parikh vector associated with the string $w\in \Sigma^*$, where $\Sigma=\{a_1,a_2,\dots, a_n\}$. For a language $L\subseteq \Sigma^*$, $\Psi_\Sigma(L)=\{\Psi_\Sigma(w)|w\in L\}$ is the Parikh image of $L$. If FL is a family of languages, PsFL denotes the family of Parikh images of languages in FL.

Next, we recall notions from graph theory.

A {\bf rooted tree} is a tree, in which a particular node is distinguished from the others and called the root node.
Let $T$ be a rooted tree. We will denote its root node by $r_T$.
Let $d$ be a node of $T\setminus\{r_T\}$.
As $T$ is a tree, there is a unique path from $d$ to $r_T$. 
The node adjacent to $d$ on that path is also unique and is called a {\bf parent node} of $d$ and is denoted by $parent_T(d)$.
We will denote the set of nodes of $T$ by $V(T)$ and set of its edges by $E(T)$.
Let $T_1, T_2$ be rooted trees. A bijection $f: V(T_1)\rightarrow V(T_2)$ is an {\bf isomorphism} iff $\{(f(u),f(v))|(u,v)\in E(T_1)\} = E(T_2)$ and $f(r_{T_1}) = r_{T_2}$. 

  
\section{Active P systems}
\label{sec:p systems}

% Membrane structure

The fundamental ingredient of a P system is the {\bf membrane structure} (see \cite{Paun2006Introduction}). It is a hierarchically arranged set of membranes, all contained in the {\bf skin membrane}. Each membrane determines a compartment, also called region, which is the space delimited from above by it and from below by the membranes placed directly inside, if any exists. Clearly, the correspondence membrane – region is one-to-one, that is why we sometimes use interchangeably these terms.
The membrane structure can be also viewed as a rooted tree with the skin membrane as the root node.

A P system consists of a membrane structure, where each membrane is labeled with a number from 1 to $m$. Each membrane contains a set of objects. Objects can be transformed into other objects and sent through a membrane according to given rules defined for membrane labels. The rules are known from the beginning for each possible membrane, even for the ones that do not exist yet, or the ones that will never exist.

In this paper we work with P systems with active membranes (Active P systems). The rules can modify the membrane structure by dissolving and creating new membranes. That is why we will define the configuration to include the membrane structure as well.

% P system

\input{p-system-definition}

\section{Simulation of register machine} % (fold)
\label{sec:simulation_of_register_machine}

\subsection{Register machine} % (fold)
\label{sub:register_machine}

\begin{definition}
  A {\bf $n$-register machine} is a tuple $M = (n,P,i,h)$, where:
  \begin{itemize}
    \item $n$ is the number of registers,
    \item $P$ is a set of labeled instructions of the form $j : (op(r),k,l)$, where $op(r)$ is an operation on register $r\leq n$, and $j$, $k$, $l$ are labels from the set $Lab(M)$ such that there are no two instructions with the same label $j$,
    \item $i$ is the initial label, and
    \item $h$ is the final label.
  \end{itemize}
\end{definition}

The machine is capable of the following instructions:
\begin{itemize}
  \item $(add(r),k,l)$ : Add one to the contents of register $r$ and proceed to instruction $k$ or to instruction $l$; in the deterministic variants usually considered in the literature we demand $k = l$.
  \item $(sub(r),k,l)$ : If register $r$ is not empty, then subtract one from its contents and go to instruction $k$, otherwise proceed to instruction $l$.
  \item $halt$ : This instruction stops the machine. This additional instruction can only be assigned to the final label $h$.
\end{itemize}

A deterministic $m$-register machine can analyze an input $(n_1,\dots,n_m)\in N_0^m$ in registers 1 to $m$, which is recognized if the register machine finally stops by the halt instruction with all its registers being empty (this last requirement is not necessary). If the machine does not halt, the analysis was not successful.

A configuration of a register machine is a tuple $(r_1, \ldots, r_m, ip)$, where $r_i$ is value of the register $i$ and $ip$ (instruction pointer) is the label of current instruction to be executed.

% subsection register_machine (end)

\subsection{Simple simulation} % (fold)
\label{sub:simple_simulation}

For a register machine with $m$ registers we will construct an active P system $(\Sigma, C_0, R_1, \ldots R_{m+1})$, where $\Sigma = \{x_j, y_j \text{~for instructions with label~} j\}\cup\{t_i \text{~for each register ~}i\}$. Skin membrane will be labeled with $m+1$, other labels correspond to registers 1 to $m$. $C_0$ will be the input word for the register machine encoded into a membrane structure by the following encoding: 

For a configuration of register machine $(r_1, r_2, \ldots r_m, ip)$ the membrane structure will consist of a skin membrane, which will contain $m$ chains consisting of $r_i$ membranes embedded one into another like in a Matryoshka doll with label $i$. The innermost membranes will contain a single object $t_i$. If $r_i = 0$ then $t_i$ is in the skin membrane and there is no membrane with label $i$. Object representing the label of the current instruction ($x_{ip}$) is in the skin membrane.

We will have following rules in the skin membrane:
\begin{itemize}
  \item $y_j \rightarrow x_j$,
  \item $x_j \rightarrow x_j\downarrow_{i}$ for instruction $j: op(i)$,
  \item $x_j, t_i \rightarrow [_1 y_k, t_i ]_1$ for instruction $j: (add(i), k, \_)$,
  \item $x_j, t_i \rightarrow l$ for instruction $j: (sub(i), \_, l)$
\end{itemize}

For the membrane $i$:
\begin{itemize}
  \item $x_j \rightarrow x_j\downarrow_{i}$ for instruction $j: op(i)$,
  \item $x_j, t_i \rightarrow [_1 y_k, t_i ]_1$ for instruction $j: (add(i), k, \_)$,
  \item $y_j \rightarrow y_j\uparrow$ for instruction $j: (op(i), \_, \_)$,
  \item $x_j, t_i \rightarrow y_k, t_i, \delta$ for instruction $j: (sub(i), k, l)$
\end{itemize}

Object $x_j$ represents the instruction currently executed. It is sent down the chain of membranes and in the innermost membrane the creation of new membrane or the dissolution is performed. Then the next instruction represented by object $y_j$ is sent upwards all the way to the skin membrane. The object $t_i$ is always present in the innermost membrane. The zero-test is implemented by rule in the skin membrane, which require the presence of $t_i$, meaning that the value of register $i$ is zero.  

If empty register halting is needed, we will consume $t_i$ symbols with the label of a halting instruction in the skin membrane.

The simulation was quite straightforward. We proved that the model is computational complete. However, the simulation is not very effective. It uses alphabet of size $2 * \text{number of instructions} + \text{number of registers}$. And its number of membranes is linearly dependent on sum of values of registers. The time needed for executing an instruction on register $i$ is linearly dependent on $r_i$.

% subsection simple_simulation (end)

\subsection{Optimalization of the simulation} % (fold)
\label{sub:optimalization_of_the_simulation}

In this subsection we address the inefficient usage of membranes in the previous simulation. New, optimized simulation will reduce it to logarithmic dependency.

For a register machine with $m$ registers we will construct an active P system, where $\Sigma = \{0,1,p,s,t\}\cup\{x_j, y_j, z_j \text{~for instructions with label~} j\}$. Skin membrane will be labeled with $m+1$, other labels correspond to registers 1 to $m$.

Assume configuration of register machine $(r_1, r_2, \ldots r_m, ip)$. For each register $i$, let $b_1b_2\ldots b_k$ be a binary representation of $r_i$. The skin membrane will contain a chain of $k$ membranes embedded one into another like in a Matryoshka doll with label $i$.
The membrane in depth $d$ will contain the object $b_{k-d}$, which is either 0 or 1. So the highest-order position in the binary number is represented by the innermost membrane and more-often incremented positions are in membranes closer to the skin membrane. Moreover, the innermost membranes contain a single object $t$. The skin membrane contains the label of the current instruction $x_{ip}$. Other membranes (not skin and not innermost) contain $s$. Object $p$ will be in all membranes except the skin membrane and direct children of skin membrane. It represents the fact that the membrane can be dissolved, while keeping at least one membrane for binary representation of the register value.


We will have following rules in the skin membrane:
\begin{itemize}
  \item $y_j \rightarrow x_j$,
  \item $x_j \rightarrow x_j\downarrow_{i}$ for instruction $j: op(i)$
\end{itemize}

For the membrane $i$ and instruction $j$:
\begin{itemize}
  \item $y_j \rightarrow y_j \uparrow$ (return the next instruction to the skin membrane).
\end{itemize}

For the membrane $i$ and instruction $j: add(i,k)$:
\begin{itemize}
  \item $x_j1 \rightarrow x_j\downarrow_{i}0$ (we decremented lower position, so we must increment higher position (011 to 100, now at 1 to 0)),
  \item $x_j0 \rightarrow y_k \uparrow 1$ (we incremented a position and can return and proceed to the next instruction),
  \item $x_j1t \rightarrow [_i 1tp]_iy_k\uparrow 0s$ (incrementing 111 to 1000).
\end{itemize}

For the membrane $i$ and instruction $j: sub(i,k,l)$:
\begin{itemize}
  \item $x_j1s \rightarrow y_k \uparrow 0s$ (we found position to decrement, proceed to the next instruction),
  \item $x_j0 \rightarrow x_j\downarrow_i 1$ (1000 is decremented to 0111 and now we encountered a 0),
  \item $x_j1tp \rightarrow z_kt \delta$ (decrementing the number of bits),
  \item $z_jst \rightarrow y_jt$ (after decremented the number of bits, remove $s$ in the new highest-order position),
  \item $x_j0t \rightarrow y_l \uparrow 0t$ (trying to decrement a zero)
\end{itemize}

\subsection{Further optimizations} % (fold)
\label{sub:further_optimizations}

Could the simulation be optimized even more? Encoding the register value to a chain of membranes is not making full use of membrane structure. There are many options how to efficiently represent an integer by a tree. For efficient implementation of the increment and decrement instructions we need an encoding with a property that a local change in value of the encoding of the entire tree corresponds to a local change in value of the encodings of its child subtrees. Stein in 1999 \cite{Stein99Plowing} proposed a boustrophedonic variant of Cantor pairing function. The implementation of an active P system simulating a register machine using this pairing function to encode child subtrees would be quite easy, but we would stick to the logarithmic time in the worst case (diagonal of the pairing function).
Catalan pairing function \cite{Stanley1986EnumerativeCombinatorics} orders full binary trees by the number of nodes. The time would be logarithmic with a base 4, which is a slight improvement, but asymptotically still the same.

% subsection further_optimizations (end)

% subsection optimalization_of_the_simulation (end)

% section simulation_of_register_machine (end)

\section{Modified membrane creation semantics} % (fold)
\label{sec:modified_membrane_creation_semantics}

In this section we will investigate the effect of other semantics of membrane creation. The previous semantics assumed an explicit membrane creation rule. If the current membrane already contains child membrane with the same label as the membrane going to be created, then the rule is not applicable, hence the membrane creation is aborted. Similar behavior is in the definition of sending objects to the child membrane. If such membrane does not exist, objects cannot be sent and the rule is not applicable.

These two behaviors are in fact complementary. It seems natural to join these two artificial rule abortions and provide a rule that will always be applicable if the precondition of left side inclusion is fulfilled.

\subsection{Semantics inject-or-create} % (fold)
\label{sub:semantics_inject_or_create}

Therefore we will have no explicit membrane creation rule. Any rule which is sending some objects to child membrane labeled $j$ will create child membrane $j$ if it does not exist.

Formally, rules can be of form:
\begin{itemize}
  \item $u\rightarrow w$, where $u\subseteq \Sigma$, $|u|\geq 1$, $w\subseteq (\Sigma\times\{\cdot, \uparrow, \downarrow_j\})$ and $1\leq j\leq m$,
  \item a dissolving rule $u\rightarrow w\delta$, where $u\subseteq \Sigma$, $|u|\geq 1$, $w\subseteq (\Sigma\times\{\cdot, \uparrow, \downarrow_j\})$ and $1\leq j\leq m$.
\end{itemize}

For an active P system $(\Sigma, C_0, R_1, R_2, \dots , R_m)$, configuration $C = (T, l, c)$, membrane $d\in V(T)$ the rule $r\in R_{l(d)}$ is {\bf applicable} iff:
\begin{itemize}
  \item $r = u\rightarrow w$ and $u\subseteq c(d)$,
  \item $r = u\rightarrow w\delta$ and $u\subseteq c(d)$ and $d\neq r_T$.
\end{itemize}
TODO: example needed (with picture?)

We will now show how the computational completeness of this variant of membrane creation is achieved by simulating the register machine. The simulation is essentially the same as in section \ref{sub:optimalization_of_the_simulation}. All the rules which are sending objects into a child membrane are already assuming that the child membrane already exists. The only difference is in the rule for membrane creation: $x_j1t \rightarrow [_i 1tp]_iy_k\uparrow 0s$. This rules is applied always in the innermost membrane with no child membranes. Modified simulation will therefore use rule $x_j1t \rightarrow 1\downarrow_i t\downarrow_i p\downarrow_i y_k\uparrow 0s$, which, when applied, creates a child membrane $i$, because no such child membrane exists.

% subsection semantics_inject_or_create (end)

\subsection{Semantics wrap-or-create} % (fold)
\label{sub:semantics_wrap_or_create}

In this variant we stick with explicit membrane creation rule, but when the membrane with the same label is already contained in the current membrane, the rule remains applicable and the child membrane will be wrapped by a new membrane with the given contents. For example, applying the rule $a \rightarrow [_2 b ]_2 c$ in the membrane 1 of membrane structure $[_1 a [_2 d ]_2 ]_1$ would result in $[_1 c [_2 b [_2 d ]_2 ]_2 ]_1$.

% subsection semantics_wrap_or_create (end)

% section modified_membrane_creation_semantics (end)

\bibliography{set}

\end{document}
