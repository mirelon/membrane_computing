\documentclass[llncs,submission,copyright,creativecommons]{../lib/lncs/llncs}
\providecommand{\event}{Cie-CS 2015} % Name of the event you are submitting to

\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}

\usepackage{fontenc}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{makeidx}
\pagestyle{headings}
\bibliographystyle{../lib/lncs/splncs}

\def\eps{\varepsilon}
\def\goodgap{\hspace{\subfigcapskip}}
\renewcommand\refname{References}

% Itemize bulet types
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\cdot$}

% Narrow texts in boxes
\providecommand{\narrow}[1]{\scalebox{.8}[1.0]{#1}}

\begin{document}
\title{Decidability of the termination problem for sequential P systems with active membranes}
\author{Michal Kováč}
\institute{Faculty of Mathematics, Physics and Informatics, Comenius University}
\date{\today}
\maketitle

\begin{abstract}
Abstract
\end{abstract}

\section{Introduction}
\label{sec:introduction}

% Bio motivation

Membrane systems (P systems) were introduced by P\u{a}un (see \cite{Paun2000108}) as distributed parallel computing devices inspired by the structure and functionality of cells.
One of the objectives is to relax the condition of using the rules in a maximally parallel way in order to find more realistic P systems from a biological point of view.
In sequential systems, only one rewriting rule is used in each step of computation.


\section{Preliminaries}
\label{sec:preliminaries}

Here we recall several notions from the classical theory of formal languages.

An {\bf alphabet} is a finite nonempty set of symbols. Usually it is denoted by $\Sigma$. A {\bf string} over an alphabet is a finite sequence of symbols from alphabet. We denote by $\Sigma^*$ the set of all strings over an alphabet $\Sigma$. By $\Sigma^+$ = $\Sigma^* - \{\eps\}$ we denote the set of all nonempty strings over $\Sigma$. A {\bf language} over the alphabet $\Sigma$ is any subset of $\Sigma^*$.

The number of occurrences of a given symbol $a\in \Sigma$ in the string $w\in \Sigma^*$ is denoted by $|w|_a$. $\Psi_\Sigma(w)=(|w|_{a_1},|w|_{a_2},\dots,|w|_{a_n})$ is called a Parikh vector associated with the string $w\in \Sigma^*$, where $\Sigma=\{a_1,a_2,\dots a_n\}$. For a language $L\subseteq \Sigma^*$, $\Psi_\Sigma(L)=\{\Psi_\Sigma(w)|w\in L\}$ is the Parikh mapping associated with $L$. If FL is a family of languages, PsFL is denoted the family of Parikh images of languages in FL.

A multiset over a set $\Sigma$ is a mapping $M: \Sigma\rightarrow \mathbb N$.
We denote by $M(a), a\in \Sigma$ the multiplicity of $a$ in the multiset $M$.
The {\bf support} of a multiset $M$ is the set $supp(M)=\{a\in \Sigma|M(a)\geq 1\}$.
It is the set of items with at least one occurrence.
A multiset is {\bf empty} when its support is empty.
A multiset $M$ with finite support $\{a_1, a_2, \dots, a_n\}$ can be represented by the string $a_1^{M(a_1)}a_2^{M(a_2)}\dots a_n^{M(a_n)}$.
We say that multiset $M_1$ is included in multiset $M_2$ if $\forall a \in supp(M_1): M_1(a)\leq M_2(a)$.
We denote it by $M_1\subseteq M_2$.
If $M_1\subseteq M_2$, the {\bf difference} of two multisets $M_2-M_1$ is defined as a multiset where $\forall a \in supp(M_2): (M_2-M_1)(a)=\max(M_2(a)-M_1(a),0)$.
The {\bf union} of two multisets $M_1\cup M_2$ is a multiset where $\forall a \in supp(M_1)\cup supp(M_2): (M_1\cup M_2)(a)=M_1(a)+M_2(a)$.
The product of multiset $M$ with natural number $n\in \mathbb N$ is a multiset where $\forall a \in supp(M): (n\cdot M)(a)=n\cdot M(a)$.

Next, we recall notions from graph theory.

A {\bf rooted tree} is a tree, in which a particular node is distinguished from the others and called the root node.
Let $T$ be a rooted tree. We will denote its root node by $r_T$.
Let $d$ be a node of $T\setminus\{r_T\}$. The node adjacent to $d$ on the only path from $d$ to $r_T$ is called a {\bf parent node} of $d$ and is denoted by $parent_T(d)$.
We will denote the set of nodes of $T$ by $V(T)$ and set of its edges by $E(T)$.
Let $T_1, T_2$ be rooted trees. A bijection $f: V(T_1)\rightarrow V(T_2)$ is an {\bf isomorphism} iff $\{(f(u),f(v))|(u,v)\in E(V(T_1))\} = E(V(T_2))$ and $f(r_{T_1}) = r_{T_2}$. 

  
\section{Active P systems}
\label{sec:p systems}

% Membrane structure

The fundamental ingredient of a P system is the {\bf membrane structure} (see \cite{Paun2006Introduction}). It is a hierarchically arranged set of membranes, all contained in the {\bf skin membrane}. Each membrane determines a compartment, also called region, which is the space delimited from above by it and from below by the membranes placed directly inside, if any exists. Clearly, the correspondence membrane – region is one-to-one, that is why we sometimes use interchangeably these terms.
Membrane structure can be also viewed as a rooted tree with the skin membrane as the root node.

% P system

\input{p-system-definition}

\subsection{Register machines} % (fold)
\label{sub:register_machines}
  As a referential universal language acceptor we will use Minsky's register machine. Such a machine runs a program consisting of numbered instructions of several simple types.

\input{r-machine-definition}
  
% subsection register_machines (end)

\section{Termination problems} % (fold)
\label{sec:termination_problems}

In this section we recall the halting problem for Turing machines. The problem is to determine, given a deterministic Turing machine and an input, whether the machine running on that input will halt. It is one of the first known undecidable problems. On the other hand, for non-deterministic machines, there are two possible meanings for halting. We could be interested either in:
\begin{itemize}
  \item whether there exists an infinite computation (the machine can run forever), or
  \item whether there exists a finite computation (the machine can halt)
\end{itemize}

We will prove the (un)decidability of these problems on active P systems with limit on total number of membranes. The results are quite interesting, because:

\begin{theorem}
  Sequential active P systems with limit on total number of membranes are universal.
\end{theorem}

\begin{proof}
  The proof of this theorem for sequential active P systems in \cite{Ibarra05Active} uses simulation of register machines and during the simulation, every configuration has at most three membranes, hence the universality holds also for sequential active P systems with limit on total number of membranes.
  \qed
\end{proof}

\subsection{Existence of infinite computation} % (fold)
\label{sub:existence_of_infinite_computation}

We will propose an algorithm for deciding existence of infinite computation. Basic idea is to consider the minimal coverability graph (\cite{Rozenberg93MinimalCoverabilityGraph}), where nodes are configurations and edge leads from the configuration $C_1$ to the configuration $C_2$, whenever there is a rule applicable in $C_1$, which results in $C_2$. The construction in \cite{Rozenberg93MinimalCoverabilityGraph} is performed on Petri nets, where the configuration consists just of a vector of natural numbers. The situation is the same for single-membrane sequential P systems. We need to modify the construction for active P systems.

A configuration $C_2 = (T_2, l_2, c_2)$ {\bf covers} configuration $C_1 = (T_1, l_1, c_1)$ iff $\exists$ isomorphism $f: T_1\rightarrow T_2$ such that $\forall d\in T_1$ the following properties hold: $l_1(d)=l_2(f(d))\wedge c_1(d)\subseteq c_2(f(d))$.

We will denote this with $C_1\leq C_2$.

\begin{lemma}
\label{rule_applicability_lemma}
  For sequential active P system with limit on total number of membranes, if $C_2 = (T_2, l_2, c_2)$ {\bf covers} configuration $C_1 = (T_1, l_1, c_1)$, then there is an isomorphism $f: T_1\rightarrow T_2$ such that if a rule $r$ is applicable in membrane $d\in T_1$, then $r$ is applicable in $f(d)$.
\end{lemma}

\begin{proof}
  Suppose $r$ is applicable in $d$. Then left side of the rule is contained within the contents of the membrane $u\subseteq c_1(d)$. Because $C_1\leq C_2$, then $c_1(d)\subseteq c_2(f(d))$ and then $u\subseteq c_2(f(d))$.

  There are three possible forms of the rule $r$.
  \begin{itemize}
    \item If $r = u\rightarrow w$, then because $r$ is applicable in $d$, $\forall (a,\downarrow_k)\in w \exists d_2\in V(T_1): l_1(d_2)=k \wedge parent_{T_1}(d_2) = d$. Because $C_1\leq C_2$, then for $f(d_2)\in V(T_2)$ the following holds: $l_2(f(d_2)) = l_1(d_2) = k$ and $parent_{T_2}(f(d_2) = f(d)$. Hence $r$ is applicable in $f(d)$.
    \item If $r = u\rightarrow w\delta$, then $d\neq r_{T_1}$. Since $f$ is an isomorphism, then also $f(d)\neq r_{T_2}$. Other properties follows from the previous case.
    \item If $r = u\rightarrow [_k v]_k$, then $|V(T_1)|<L$. Isomorphism preserves number of nodes, hence $|V(T_2)| = |V(T_1)| < L$ and $r$ is applicable in $f(d)$. \qed
  \end{itemize}
\end{proof}

Now, we will define the encoding of a configuration $C = (T, l, c)$ into a tuple of integers.

A membrane $d\in T$ will be encoded as $n+m$-tuple $enc(d)\in\mathbb N^{(n+m)}$, where first $n$ numbers will be actual counts of objects: $enc(d)_i=c(d)(a_i)$ for $i\leq n$. Next $m$ numbers will encode the membrane label: $enc(d)_{n+j} = 0$ for $l(d)\neq j\leq m$ and $enc(d)_{n+l(d)} = 1$.

The entire tree will be encoded into concatenated sequences of encoded nodes in the inorder traversal order. This sequence is then padded with zeroes to have length $(n+m)L$ as that is the maximal length of encoded tree. 

Since there are only finitely many non-isomorphic trees with at most $L$ nodes (\cite{Cayley1881RootedTrees}), there is a constant $z$ such that we can uniquely assign the tree an order number $o(T) \leq z$.

The configuration will be encoded in tuple which consists of $z$ parts. All but the part with index $o(T)$ will contain just zeros. The part with index $o(T)$ will contain the encoding of the tree.

\begin{lemma}
\label{encoding_lemma}
  For configurations $C_1 = (T_1, l_1, c_1)$ and $C_2 = (T_2, l_2, c_2)$, $enc(C_1) \leq enc(C_2)\Rightarrow C_1\leq C_2$.
\end{lemma}

\begin{proof}
  If the $enc(C_1)\leq enc(C_2)$, then $o(T_1)=o(T_2)$, so the trees are isomorphic. For every membrane $d\in T_1$, $l_1(d)=l_2(f(d))$ and $c_1(d)\subseteq c_2(f(d))$. Hence, $C_1\leq C_2$.
  \qed
\end{proof}

\begin{lemma}
\label{infinite_sequence_of_configurations_lemma}
  For sequential active P system with limit on total number of membranes $L$ for every inifite sequence of configurations $\{C_i\}_{i=0}^\infty\exists i<j: C_i\leq C_j$.
\end{lemma}

\begin{proof}
  Suppose an infinite sequence $\{enc(C_i)\}_{i=0}^\infty$. We use a variation of Dickson's lemma (\cite{Figueira11Dickson}): Every infinite sequence of tuples from $\mathbb N^k$ contains an increasing pair. Applied to our sequence, there are two positions $i<j: enc(C_i)\leq enc(C_j)$. From lemma \ref{encoding_lemma}, $C_i\leq C_2$.
  \qed
\end{proof}

\begin{theorem}
  Existence of infinite computation for active P systems with limit on total number of membranes is decidable.
\end{theorem}

\begin{proof}
  Algorithm for deciding the problem will traverse the reachability graph. When it encounters a configuration that covers another configuration, from lemma \ref{rule_applicability_lemma} follows that the same rules can be applied repeatedly, so the algorithm will halt with the answer YES.
  Otherwise, the algorithm will answer NO.
  Algorithm will always halt, because if there was an infinite computation, from lemma \ref{infinite_sequence_of_configurations_lemma} there would be two increasing configurations which is already covered in the YES case.
  \qed
\end{proof}

% subsection existence_of_infinite_computation (end)

\subsection{Existence of finite computation} % (fold)
\label{sub:existence_of_finite_computation}

\begin{theorem}
  Existence of finite computation for active P systems with limit on total number of membranes is undecidable.
\end{theorem}

\begin{proof}
  Either reduce it to detection of empty language or to reachability.
\end{proof}

% subsection existence_of_finite_computation (end)

% section termination_problems (end)

\section{Conclusion}
\label{sec:conclusion}
We have studied \dots

\bibliography{cie}

\end{document}
