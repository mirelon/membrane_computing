This chapter is about some basic notions of computer science which will be used through the work. We start by defining formal languages and basic models (grammars, machines) that define language families and end by defining multiset languages.

\section{Formal languages} % (fold)
\label{sec:formal_languages}

Our study is based on the classical theory of formal languages. We will recall some definitions:

\begin{definition}
An {\bf alphabet} is a finite nonempty set of symbols.
\end{definition}

\begin{definition}
A {\bf string} over an alphabet is a finite sequence of symbols from alphabet.
\end{definition}

The length of the string $s$ is denoted by $|s|$. We denote by $V^*$ the set of all strings over an alphabet $V$. By $V^+$ = $V^* - \{\eps\}$ we denote the set of all nonempty strings over V.

\begin{definition}
A {\bf language} over the alphabet $V$ is any subset of $V^*$.
\end{definition}

\begin{definition}
A {\bf family of languages} is a set of languages.
\end{definition}


\section{Formal grammars} % (fold)
\label{sec:formal_grammars}

\begin{definition}
A {\bf formal grammar} is a tuple $G = (N,T,P,\sigma)$, where
\begin{itemize}
  \item $N, T$ are disjoint alphabets of non-terminal and terminal symbols,
  \item $\sigma\in N$ is the initial non-terminal,
  \item $P$ is a finite set of rewriting rules of the form $u\rightarrow v$, with $u\in (N\cup T)^*N(N\cup T)^*$ and $v\in (N\cup T)^*$.
\end{itemize}
\end{definition}

\begin{definition}
A {\bf rewriting step} in the grammar $G$ is a binary relation $\Rightarrow$ on $(N\cup T)^*$, where $x\Rightarrow y$ only if $\exists w_1, w_2\in (N\cup T)^+$ and a rule $u\rightarrow v \in P$ such that $x=w_1uw_2$ and $y=w_1vw_2$.
\end{definition}

\begin{definition}
Language defined by a grammar $G$ is a set $L(G)=\{w\in T^*|\sigma\Rightarrow w\}$.
\end{definition}

Languages that can be generated by a formal grammar are the recursively enumerable languages $RE$.

% section formal_languages (end)

% section formal_grammars (end)

\section{Chomsky hierarchy} % (fold)
\label{sec:chomsky_hierarchy}

In this section we introduce several well-known families of languages.

\begin{definition}
A {\bf regular grammar} is a formal grammar, where the rewriting rules are of the form $u\rightarrow v$, where $u\in N$ and $v\in T^*(N\cup \{\eps\})$.
\end{definition}

\begin{definition}
A {\bf regular language} is a language generated by a regular grammar. The family of regular languages is denoted $R$.
\end{definition}

\begin{definition}
A {\bf context-free grammar} is a formal grammar, where rewriting rules are of the form $u\rightarrow v$, where $u\in N$ and $v\in (N\cup T)^*$.
\end{definition}

\begin{definition}
A {\bf context-free language} is a language generated by a context-free grammar. The family of context-free languages is denoted $CF$.
\end{definition}

\begin{definition}
A {\bf context-sensitive grammar} is a formal grammar, where rewriting rules are of the form $u\rightarrow v$, where $u\in (N\cup T)^*N(N\cup T)^*$, $v\in (N\cup T)^*$ and $|u| < |v|$.
\end{definition}

\begin{definition}
A {\bf context-sensitive language} is a language generated by a context-sensitive grammar. The family of context-sensitive languages is denoted $CS$.
\end{definition}

These families of languages forms the Chomsky hierarchy by means of inclusions: $R \subset CF \subset CS \subset RE$.

% section chomsky_hierarchy (end)

\section{Matrix grammars} % (fold)
\label{sec:matrix_grammars}

\begin{definition}
A {\bf matrix grammar} is a tuple $G = (N,T,M,\sigma)$, where:
\begin{itemize}
  \item $N, T$ are disjoint alphabets of non-terminal and terminal symbols,
  \item $\sigma\in N$ is the initial non-terminal,
  \item $M$ is a finite set of matrices, which are sequences of context-free rules of the form $u\rightarrow v$, where $u\in N$ and $v\in (N\cup T)^*$.
\end{itemize}
\end{definition}

\begin{definition}
A {\bf rewriting step} $x\Rightarrow y$ holds only if there is a matrix $(u_1\rightarrow v_1, u_2\rightarrow v_2, \dots, u_n\rightarrow v_n) \in M$ such that for each $1\leq i\leq n$ the following holds: $x_i = x_i^{\prime}u_ix_i^{\prime\prime}$ and $x_{i+1} = x_i^{\prime}v_ix_i^{\prime\prime}$, where $x_i, x_i^{\prime}, x_i^{\prime\prime} \in (N\cup T)^*$ and $x_1 = x$ and $x_{n+1} = y$.
\end{definition}

\begin{example}
Consider the matrix grammar $G=(\{\sigma, X,Y\}, \{ a,b,c\}, M, \sigma)$, where $M$ contains three matrices: $[S\rightarrow XY], [X\rightarrow aXb, Y\rightarrow cY], [X\rightarrow ab, Y\rightarrow c]$. There are only context-free rules, yet the grammar generate the context-sensitive language $\{a^nb^nc^n|n\geq 1\}$.
\end{example}

The family of matrix grammars is denoted $MAT$.

It is known that $CF \subset MAT \subset RE$. Interestingly, $MAT \cap {a}^* \subset R$ (see \cite{Besozzi:PhD:2004}).

% section matrix_grammars (end)

\section{Register machines} % (fold)
\label{sec:register_machines}

% We will use the notion of register machine as defined in our article

\input{../inh/r-machine-definition}

% section register_machines (end)

\section{Lindenmayer systems} % (fold)
\label{sec:lindenmayer_systems}

In 1968, a Hungarian botanist and theoretical biologist Aristid Lindenmayer introduced \cite{Lindenmayer68} a new string rewriting algorithm named Lindenmayer systems (or L-systems for short). They are used by biologists and theoretical computer scientists to mathematically model growth processes of living organisms, especially plants. The difference with Chomsky grammars is that rewriting is parallel, not sequential.

The simplest version of L-systems assumes that the development of a cell is free of influence of other cells.
This type of L-systems is called $0L$ systems, where ``0'' stands for zero-sided communication between cells.

\begin{definition}
A $0L$ system is a triple $(\Sigma, P, \omega)$, where $\Sigma$ is an alphabet, $\omega$ is a word over $\Sigma$ and $P$ is a finite set of rewriting rules of the form $a\rightarrow x$, where $a\in\Sigma, x\in\Sigma^*$.
\end{definition}

It is assumed there is at least one rewriting rule for each letter of $\Sigma$. $0L$ system works in parallel way, so all the symbols are rewritten in each step.

\begin{example}
Consider a $0L$ system with alphabet $\Sigma = \{a,b\}$, initial word $\omega = a$ and rewriting rules $P = \{a\rightarrow b, b\rightarrow ab\}$.
Since in this system there is exactly one rule for every letter of the alphabet, the rewriting is thus deterministic and the generated words will be $\{a, b, ab, bab, abbab, \dots \}$. 
\end{example}

$1L$ systems allows the rewriting rules to include context of size 1, so it allows for rules of type $yaz\rightarrow x$.

L-systems with tables ($T$) have several sets of rewriting rules instead of just one set. At one step of the rewriting process, rules belonging to the same set have to be applied. The biological motivation for introducing tables is that one may want different rules to take care of different environmental conditions (heat, light, etc.) or of different stages of development.

\begin{definition}
An extended ($E0L$) system is a pair $G_1 = (G, \Sigma_T)$, where $G = (\Sigma, P, \omega)$ is an $0L$ system, where $\Sigma_T \subseteq \Sigma$, referred to as the terminal alphabet. The language generated by $G_1$ is defined by $L(G_1) = L(G)\cap \Sigma_T^*$.
\end{definition}

Such languages are called $E0L$ languages. $E0L$ languages with tables are called $ET0L$ languages.

It is known that $CF \subset E0L \subset ET0L \subset CS$ (see section \ref{sec:chomsky_hierarchy} for definitions of $CF$ and $CS$).
% section lindenmayer_systems (end)

\section{Semilinear sets} % (fold)
\label{sec:semilinear_sets}

% section semilinear_sets (end)

\section{Vector addition systems} % (fold)
\label{sec:vector_addition_systems}

% section vector_addition_systems (end)

\section{Petri nets} % (fold)
\label{sec:petri_nets}

% section petri_nets (end)

\section{BÃ¼chi automaton} % (fold)
\label{sec:buchi_automaton}

% section buchi_automaton (end)

\section{Calculi of looping sequences} % (fold)
\label{sec:calculi_of_looping_sequences}

% section calculi_of_looping_sequences (end)

\section{Graph theory} % (fold)
\label{sec:graph_theory}

% section graph_theory (end)

\section{Multisets} % (fold)
\label{sec:multisets}

\begin{definition}
A multiset over a set $X$ is a mapping $M: X\rightarrow \mathbb N$.
\end{definition}

We denote by $M(x), x\in X$ the multiplicity of $x$ in the multiset $M$.

\begin{definition}
The {\bf support} of a multiset $M$ is the set $supp(M)=\{x\in X|M(x)\geq 1\}$.
\end{definition}

It is the set of items with at least one occurrence.

\begin{definition}
A multiset is {\bf empty} when its support is empty.
\end{definition}

A multiset $M$ with finite support $X = \{x_1, x_2, \dots, x_n\}$ can be represented by the string $x_1^{M(x_1)}x_2^{M(x_2)}\dots x_n^{M(x_n)}$.
As elements of a multiset can also be strings, we separate them with the pipe symbol, e.g. $element|element|other\_element$.

\begin{definition}
Multiset inclusion. We say that multiset $M_1$ is included in multiset $M_2$ if $\forall x \in X: M_1(x)\leq M_2(x)$. We denote it by $M_1\subseteq M_2$.
\end{definition}

\begin{definition}
The {\bf union} of two multisets $M_1\cup M_2$ is a multiset where $\forall x \in X: (M_1\cup M_2)(x)=M_1(x)+M_2(x)$.
\end{definition}

\begin{definition}
The {\bf difference} of two multisets $M_1-M_2$ is a multiset where $\forall x \in X: (M_1-M_2)(x)=M_1(x)-M_2(x)$.
\end{definition}

\begin{definition}
Product of multiset $M$ with natural number $n\in \mathbb N$ is a multiset where $\forall x \in X: (n\cdot M)(x)=n\cdot M(x)$.  
\end{definition}

% section multisets (end)

\section{Multiset languages} % (fold)
\label{sec:multiset_languages}

The number of occurrences of a given symbol $a\in V$ in the string $w\in V^*$ is denoted by $|w|_a$.

\begin{definition}
$\Psi_V(w)=(|w|_{a_1},|w|_{a_2},\dots,|w|_{a_n})$ is called a Parikh vector associated with the string $w\in V^*$, where $V=\{a_1,a_2,\dots a_n\}$.
\end{definition}

\begin{definition}
For a language $L\subseteq V^*$, $\Psi_V(L)=\{\Psi_V(w)|w\in L\}$ is the Parikh mapping associated with $V$.
\end{definition}

\begin{example}
Consider an alphabet $V=\{a,b\}$ and a language $L=\{a, ab, ba\}$.
$\Psi_V(L)=\{(1,0), (1,1)\}$. Notice that Parikh image of $L$ has only 2 element while $L$ has 3 elements.
\end{example}

\begin{definition}
If $FL$ is a family of languages, by $PsFL$ we denote the family of Parikh images of languages in $FL$.
\end{definition}

% section multiset_languages (end)

\section{Bisimulations} % (fold)
\label{sec:bisimulations}
\input{bisimulation}
% section bisimulations (end)